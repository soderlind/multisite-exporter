<?php
/**
 * Export functionality class.
 *
 * @since      1.0.1
 * @package    Multisite_Exporter
 * @subpackage Multisite_Exporter/Export
 */

// If this file is called directly, abort.
if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

/**
 * Export functionality class.
 */
class ME_Export {

	/**
	 * The single instance of the class.
	 *
	 * @since  1.0.1
	 * @var    ME_Export
	 */
	protected static $_instance = null;

	/**
	 * Main ME_Export Instance.
	 *
	 * @return ME_Export - Main instance.
	 */
	public static function instance() {
		if ( is_null( self::$_instance ) ) {
			self::$_instance = new self();
		}
		return self::$_instance;
	}

	/**
	 * Constructor.
	 */
	public function __construct() {
		// Constructor code here if needed
	}

	/**
	 * Custom XML CDATA wrapper for our own export
	 */
	public function wxr_cdata( $str ) {
		if ( ! seems_utf8( $str ) ) {
			$str = utf8_encode( $str );
		}
		$str = '<![CDATA[' . str_replace( ']]>', ']]]]><![CDATA[>', $str ) . ']]>';
		return $str;
	}

	/**
	 * Generate a custom WXR export without using WordPress core export functions
	 * This avoids the headers and function redeclaration issues
	 * 
	 * @param array $args Export arguments.
	 * @return string XML content
	 */
	public function generate_export( $args = array() ) {
		global $wpdb, $post;

		// Set default arguments
		$defaults = [ 
			'content'    => 'all',
			'author'     => false,
			'category'   => false,
			'start_date' => false,
			'end_date'   => false,
			'status'     => false,
			'post_type'  => '',
		];
		$args     = wp_parse_args( $args, $defaults );

		// Start XML output
		$output = '<?xml version="1.0" encoding="' . get_bloginfo( 'charset' ) . "\" ?>\n";
		$output .= "<!-- This is a WordPress eXtended RSS file generated by Multisite Exporter plugin -->\n";
		$output .= '<rss version="2.0" xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/" ';
		$output .= 'xmlns:content="http://purl.org/rss/1.0/modules/content/" ';
		$output .= 'xmlns:wfw="http://wellformedweb.org/CommentAPI/" ';
		$output .= 'xmlns:dc="http://purl.org/dc/elements/1.1/" ';
		$output .= 'xmlns:wp="http://wordpress.org/export/1.2/">';
		$output .= "\n<channel>\n";

		// Add site info
		$output .= '<title>' . $this->wxr_cdata( get_bloginfo( 'name' ) ) . '</title>';
		$output .= '<link>' . get_bloginfo( 'url' ) . '</link>';
		$output .= '<description>' . $this->wxr_cdata( get_bloginfo( 'description' ) ) . '</description>';
		$output .= '<pubDate>' . gmdate( 'D, d M Y H:i:s +0000' ) . '</pubDate>';
		$output .= '<language>' . $this->wxr_cdata( get_bloginfo( 'language' ) ) . '</language>';
		$output .= '<wp:wxr_version>1.2</wp:wxr_version>';
		$output .= '<wp:base_site_url>' . ( is_multisite() ? network_home_url() : get_bloginfo( 'url' ) ) . '</wp:base_site_url>';
		$output .= '<wp:base_blog_url>' . get_bloginfo( 'url' ) . '</wp:base_blog_url>';

		// Build post query
		$where = "post_status != 'auto-draft'";
		$join  = "";

		if ( 'all' !== $args[ 'content' ] && post_type_exists( $args[ 'content' ] ) ) {
			$ptype = get_post_type_object( $args[ 'content' ] );
			if ( ! $ptype->can_export ) {
				$args[ 'content' ] = 'post';
			}
			$where .= $wpdb->prepare( " AND post_type = %s", $args[ 'content' ] );
		} else if ( $args[ 'post_type' ] ) {
			$where .= $wpdb->prepare( " AND post_type = %s", $args[ 'post_type' ] );
		} else {
			$post_types   = get_post_types( [ 'can_export' => true ] );
			$placeholders = implode( ',', array_fill( 0, count( $post_types ), '%s' ) );
			$where .= $wpdb->prepare( " AND post_type IN ($placeholders)", $post_types );
		}

		// Filter by status
		if ( $args[ 'status' ] && ( 'post' === $args[ 'content' ] || 'page' === $args[ 'content' ] ) ) {
			$where .= $wpdb->prepare( " AND post_status = %s", $args[ 'status' ] );
		}

		// Filter by category
		if ( $args[ 'category' ] && 'post' === $args[ 'content' ] ) {
			$term = term_exists( $args[ 'category' ], 'category' );
			if ( $term ) {
				$join  = "INNER JOIN {$wpdb->term_relationships} ON ({$wpdb->posts}.ID = {$wpdb->term_relationships}.object_id)";
				$where .= $wpdb->prepare( " AND {$wpdb->term_relationships}.term_taxonomy_id = %d", $term[ 'term_taxonomy_id' ] );
			}
		}

		// Filter by author
		if ( $args[ 'author' ] ) {
			$where .= $wpdb->prepare( " AND post_author = %d", $args[ 'author' ] );
		}

		// Filter by date
		if ( $args[ 'start_date' ] ) {
			$where .= $wpdb->prepare( " AND post_date >= %s", gmdate( 'Y-m-d', strtotime( $args[ 'start_date' ] ) ) );
		}

		if ( $args[ 'end_date' ] ) {
			$where .= $wpdb->prepare( " AND post_date < %s", gmdate( 'Y-m-d', strtotime( '+1 month', strtotime( $args[ 'end_date' ] ) ) ) );
		}

		// Get posts
		$posts = $wpdb->get_results( "SELECT * FROM {$wpdb->posts} $join WHERE $where ORDER BY post_date_gmt ASC" );

		// Get authors
		$authors = [];
		foreach ( $posts as $post ) {
			$authors[ $post->post_author ] = get_userdata( $post->post_author );
		}

		// Add authors to XML
		foreach ( $authors as $author ) {
			if ( ! $author )
				continue;

			$output .= "\t<wp:author>";
			$output .= '<wp:author_id>' . $author->ID . '</wp:author_id>';
			$output .= '<wp:author_login>' . $this->wxr_cdata( $author->user_login ) . '</wp:author_login>';
			$output .= '<wp:author_email>' . $this->wxr_cdata( $author->user_email ) . '</wp:author_email>';
			$output .= '<wp:author_display_name>' . $this->wxr_cdata( $author->display_name ) . '</wp:author_display_name>';
			$output .= '<wp:author_first_name>' . $this->wxr_cdata( $author->first_name ) . '</wp:author_first_name>';
			$output .= '<wp:author_last_name>' . $this->wxr_cdata( $author->last_name ) . '</wp:author_last_name>';
			$output .= "</wp:author>\n";
		}

		// Add categories
		$categories = get_categories( [ 'get' => 'all' ] );
		foreach ( $categories as $category ) {
			$output .= "\t<wp:category>";
			$output .= '<wp:term_id>' . $category->term_id . '</wp:term_id>';
			$output .= '<wp:category_nicename>' . $this->wxr_cdata( $category->slug ) . '</wp:category_nicename>';
			$output .= '<wp:category_parent>' . $this->wxr_cdata( $category->parent ? get_category( $category->parent )->slug : '' ) . '</wp:category_parent>';
			$output .= '<wp:cat_name>' . $this->wxr_cdata( $category->name ) . '</wp:cat_name>';
			$output .= '<wp:category_description>' . $this->wxr_cdata( $category->description ) . '</wp:category_description>';
			$output .= "</wp:category>\n";
		}

		// Add tags
		$tags = get_tags( [ 'get' => 'all' ] );
		foreach ( $tags as $tag ) {
			$output .= "\t<wp:tag>";
			$output .= '<wp:term_id>' . $tag->term_id . '</wp:term_id>';
			$output .= '<wp:tag_slug>' . $this->wxr_cdata( $tag->slug ) . '</wp:tag_slug>';
			$output .= '<wp:tag_name>' . $this->wxr_cdata( $tag->name ) . '</wp:tag_name>';
			$output .= '<wp:tag_description>' . $this->wxr_cdata( $tag->description ) . '</wp:tag_description>';
			$output .= "</wp:tag>\n";
		}

		// Add posts
		foreach ( $posts as $post ) {
			setup_postdata( $post );

			$output .= "\t<item>\n";
			$output .= '<title>' . $this->wxr_cdata( get_the_title( $post->ID ) ) . '</title>';
			$output .= '<link>' . get_permalink( $post->ID ) . '</link>';
			$output .= '<pubDate>' . mysql2date( 'D, d M Y H:i:s +0000', get_post_time( 'Y-m-d H:i:s', true, $post->ID ), false ) . '</pubDate>';
			$output .= '<dc:creator>' . $this->wxr_cdata( get_the_author_meta( 'login', $post->post_author ) ) . '</dc:creator>';
			$output .= '<guid isPermaLink="false">' . get_the_guid( $post->ID ) . '</guid>';
			$output .= '<description></description>';
			$output .= '<content:encoded>' . $this->wxr_cdata( $post->post_content ) . '</content:encoded>';
			$output .= '<excerpt:encoded>' . $this->wxr_cdata( $post->post_excerpt ) . '</excerpt:encoded>';
			$output .= '<wp:post_id>' . $post->ID . '</wp:post_id>';
			$output .= '<wp:post_date>' . $this->wxr_cdata( $post->post_date ) . '</wp:post_date>';
			$output .= '<wp:post_date_gmt>' . $this->wxr_cdata( $post->post_date_gmt ) . '</wp:post_date_gmt>';
			$output .= '<wp:post_modified>' . $this->wxr_cdata( $post->post_modified ) . '</wp:post_modified>';
			$output .= '<wp:post_modified_gmt>' . $this->wxr_cdata( $post->post_modified_gmt ) . '</wp:post_modified_gmt>';
			$output .= '<wp:comment_status>' . $this->wxr_cdata( $post->comment_status ) . '</wp:comment_status>';
			$output .= '<wp:ping_status>' . $this->wxr_cdata( $post->ping_status ) . '</wp:ping_status>';
			$output .= '<wp:post_name>' . $this->wxr_cdata( $post->post_name ) . '</wp:post_name>';
			$output .= '<wp:status>' . $this->wxr_cdata( $post->post_status ) . '</wp:status>';
			$output .= '<wp:post_parent>' . $post->post_parent . '</wp:post_parent>';
			$output .= '<wp:menu_order>' . $post->menu_order . '</wp:menu_order>';
			$output .= '<wp:post_type>' . $this->wxr_cdata( $post->post_type ) . '</wp:post_type>';
			$output .= '<wp:post_password>' . $this->wxr_cdata( $post->post_password ) . '</wp:post_password>';
			$output .= '<wp:is_sticky>' . ( is_sticky( $post->ID ) ? 1 : 0 ) . '</wp:is_sticky>';

			if ( 'attachment' === $post->post_type ) {
				$output .= '<wp:attachment_url>' . $this->wxr_cdata( wp_get_attachment_url( $post->ID ) ) . '</wp:attachment_url>';
			}

			// Add post terms
			$taxonomies = get_object_taxonomies( $post->post_type );
			if ( ! empty( $taxonomies ) ) {
				$terms = wp_get_object_terms( $post->ID, $taxonomies );
				foreach ( $terms as $term ) {
					$output .= "\t\t<category domain=\"{$term->taxonomy}\" nicename=\"{$term->slug}\">" . $this->wxr_cdata( $term->name ) . "</category>\n";
				}
			}

			// Add postmeta
			$postmeta = $wpdb->get_results( $wpdb->prepare( "SELECT * FROM $wpdb->postmeta WHERE post_id = %d", $post->ID ) );
			foreach ( $postmeta as $meta ) {
				if ( '_edit_lock' === $meta->meta_key ) {
					continue;
				}
				$output .= "\t\t<wp:postmeta>\n";
				$output .= "\t\t\t<wp:meta_key>" . $this->wxr_cdata( $meta->meta_key ) . "</wp:meta_key>\n";
				$output .= "\t\t\t<wp:meta_value>" . $this->wxr_cdata( $meta->meta_value ) . "</wp:meta_value>\n";
				$output .= "\t\t</wp:postmeta>\n";
			}

			// Add comments
			$comments = $wpdb->get_results( $wpdb->prepare( "SELECT * FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_approved <> 'spam'", $post->ID ) );
			foreach ( $comments as $comment ) {
				$output .= "\t\t<wp:comment>\n";
				$output .= "\t\t\t<wp:comment_id>" . $comment->comment_ID . "</wp:comment_id>\n";
				$output .= "\t\t\t<wp:comment_author>" . $this->wxr_cdata( $comment->comment_author ) . "</wp:comment_author>\n";
				$output .= "\t\t\t<wp:comment_author_email>" . $this->wxr_cdata( $comment->comment_author_email ) . "</wp:comment_author_email>\n";
				$output .= "\t\t\t<wp:comment_author_url>" . esc_url_raw( $comment->comment_author_url ) . "</wp:comment_author_url>\n";
				$output .= "\t\t\t<wp:comment_author_IP>" . $this->wxr_cdata( $comment->comment_author_IP ) . "</wp:comment_author_IP>\n";
				$output .= "\t\t\t<wp:comment_date>" . $this->wxr_cdata( $comment->comment_date ) . "</wp:comment_date>\n";
				$output .= "\t\t\t<wp:comment_date_gmt>" . $this->wxr_cdata( $comment->comment_date_gmt ) . "</wp:comment_date_gmt>\n";
				$output .= "\t\t\t<wp:comment_content>" . $this->wxr_cdata( $comment->comment_content ) . "</wp:comment_content>\n";
				$output .= "\t\t\t<wp:comment_approved>" . $this->wxr_cdata( $comment->comment_approved ) . "</wp:comment_approved>\n";
				$output .= "\t\t\t<wp:comment_type>" . $this->wxr_cdata( $comment->comment_type ) . "</wp:comment_type>\n";
				$output .= "\t\t\t<wp:comment_parent>" . $comment->comment_parent . '</wp:comment_parent>';
				$output .= "\t\t\t<wp:comment_user_id>" . $comment->user_id . '</wp:comment_user_id>';

				// Comment meta
				$commentmeta = $wpdb->get_results( $wpdb->prepare( "SELECT * FROM $wpdb->commentmeta WHERE comment_id = %d", $comment->comment_ID ) );
				foreach ( $commentmeta as $meta ) {
					$output .= "\t\t\t<wp:commentmeta>\n";
					$output .= "\t\t\t\t<wp:meta_key>" . $this->wxr_cdata( $meta->meta_key ) . "</wp:meta_key>\n";
					$output .= "\t\t\t\t<wp:meta_value>" . $this->wxr_cdata( $meta->meta_value ) . "</wp:meta_value>\n";
					$output .= "\t\t\t</wp:commentmeta>\n";
				}

				$output .= "\t\t</wp:comment>\n";
			}

			$output .= "\t</item>\n";
		}

		$output .= "</channel>\n";
		$output .= "</rss>";

		return $output;
	}

	/**
	 * Download a single export file.
	 * 
	 * @param string $file_name The file name to download.
	 */
	public function download_export_file( $file_name ) {
		// Get the export directory path
		$init       = ME_Init::instance();
		$export_dir = $init->get_export_directory();
		$file_path  = trailingslashit( $export_dir ) . $file_name;

		// Check if file exists
		if ( ! file_exists( $file_path ) ) {
			wp_die( 'File not found.' );
		}

		// Force download
		header( 'Content-Description: File Transfer' );
		header( 'Content-Type: application/xml' );
		header( 'Content-Disposition: attachment; filename="' . basename( $file_path ) . '"' );
		header( 'Content-Length: ' . filesize( $file_path ) );
		header( 'Cache-Control: must-revalidate' );
		header( 'Pragma: public' );
		header( 'Expires: 0' );

		readfile( $file_path );
		exit;
	}
}